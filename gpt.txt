Привет!
Мне нужна помощь. У меня некорректно работает отображение плейсхолдера для Task если я взаимодействую с той же колонкой, в которой эта задача была расположена. Видимый плейсхолдер либо чуть ниже того места, где располагается невидимый, либо вообще наслаивается на существующую карточку.  Для других колонок всё корректно. Вот код двух компонентов. Помоги пожалуйста!

import useLocalStorage from "use-local-storage";
import Column from "./Column";
import { TColumn, Id, TTask } from "../types";
import {
  DragDropContext,
  Draggable,
  DragStart,
  DragUpdate,
  Droppable,
  DropResult,
} from "react-beautiful-dnd";
import { useCallback, useState } from "react";
import { isEmpty } from "lodash";

interface PlaceholderProps {
  clientHeight?: number;
  clientWidth?: number;
  clientX?: number;
  clientY?: number;
}

const Board = () => {
  const [columns, setColumns] = useLocalStorage<TColumn[]>(
    "kanban-columns",
    []
  );
  const [columnPlaceholderProps, setColumnPlaceholderProps] =
    useState<PlaceholderProps>({});
  const [taskPlaceholderProps, setTaskPlaceholderProps] =
    useState<PlaceholderProps>({});

  const onDragStart = useCallback((event: DragStart) => {
    const draggedDOM = document.querySelector(
      `[data-rbd-drag-handle-draggable-id='${event.draggableId}']`
    );
    if (!draggedDOM) return;

    const { clientHeight, clientWidth } = draggedDOM;
    const sourceIndex = event.source.index;

    const parentNode = draggedDOM.parentNode as HTMLElement;
    const paddingTop = parseFloat(
      window.getComputedStyle(parentNode).paddingTop
    );
    const paddingLeft = parseFloat(
      window.getComputedStyle(parentNode).paddingLeft
    );

    const clientY =
      paddingTop +
      Array.from(parentNode.children)
        .slice(0, sourceIndex)
        .reduce((total, curr) => {
          const style = window.getComputedStyle(curr);
          const marginBottom = parseFloat(style.marginBottom);
          return total + curr.clientHeight + marginBottom;
        }, 0);

    if (event.type === "column") {
      setColumnPlaceholderProps({
        clientHeight,
        clientWidth,
        clientY,
        clientX: paddingLeft,
      });
    } else if (event.type === "task") {
      setTaskPlaceholderProps({
        clientHeight,
        clientWidth,
        clientY,
        clientX: paddingLeft,
      });
    }
  }, []);

  const onDragUpdate = useCallback((event: DragUpdate) => {
    if (!event.destination) {
      setColumnPlaceholderProps({});
      setTaskPlaceholderProps({});
      return;
    }

    const { destination, draggableId, type } = event;

    const draggedDOM = document.querySelector(
      `[data-rbd-drag-handle-draggable-id='${draggableId}']`
    );
    if (!draggedDOM) return;

    const { clientHeight, clientWidth } = draggedDOM;
    const destinationIndex = event.destination.index;
    const parentNode = draggedDOM.parentNode as HTMLElement;

    const children = Array.from(parentNode.children).filter(
      (child) => !child.classList.contains("placeholder")
    );
    let clientY = 0;

    if (event.type === "column") {
      if (destinationIndex === event.source.index) {
        clientY = parentNode.clientHeight - clientHeight;
      } else if (destinationIndex < children.length) {
        const destinationNode = children[destinationIndex];
        clientY =
          destinationNode.getBoundingClientRect().top -
          parentNode.getBoundingClientRect().top;
      } else {
        const lastNode = children[children.length - 1];
        clientY =
          lastNode.getBoundingClientRect().bottom -
          parentNode.getBoundingClientRect().top;
      }

      const clientX = event.destination.index * (clientWidth + 12);

      setColumnPlaceholderProps({
        clientHeight,
        clientWidth,
        clientY,
        clientX,
      });
    }

    const droppableParent = document.querySelector(
      `[data-rbd-droppable-id='${destination.droppableId}']`
    ) as HTMLElement;

    if (!droppableParent) return;

    if (type === "task") {
      const droppableParent = document.querySelector(
        `[data-rbd-droppable-id='${destination.droppableId}']`
      ) as HTMLElement;
  
      if (!droppableParent) return;
      const children = Array.from(droppableParent.children).filter(
        (child) => !child.classList.contains("placeholder")
      );
  
      let clientY = 0;
  
      if (children.length === 0 || destinationIndex === 0) {
        clientY = 0;
      } else if (destinationIndex >= children.length) {
        const lastChild = children[children.length - 1] as HTMLElement;
        const lastChildStyle = window.getComputedStyle(lastChild);
  
        clientY =
          lastChild.offsetTop +
          lastChild.offsetHeight +
          parseFloat(lastChildStyle.marginBottom || "0");
      } else {
        const destinationChild = children[destinationIndex] as HTMLElement;
        const destinationChildStyle = window.getComputedStyle(destinationChild);
  
        clientY =
          destinationChild.offsetTop -
          parseFloat(destinationChildStyle.marginTop || "0");
      }
  
      setTaskPlaceholderProps({
        clientHeight,
        clientWidth,
        clientY,
        clientX: 0, 
      });
    }
  }, []);

  const onDragEnd = useCallback(
    (result: DropResult) => {
      setColumnPlaceholderProps({});
      setTaskPlaceholderProps({});
      const { destination, source, type } = result;

      if (!destination) return;

      if (type === "column") {
        const newColumns = [...columns];
        const [removed] = newColumns.splice(source.index, 1);
        newColumns.splice(destination.index, 0, removed);
        setColumns(newColumns);
        return;
      }

      setColumns(() => {
        const newColumns = [...columns];

        const sourceColumn = newColumns.find(
          (col) => col.id === source.droppableId
        );
        const destColumn = newColumns.find(
          (col) => col.id === destination.droppableId
        );

        if (!sourceColumn || !destColumn) return newColumns;

        const [movedTask] = sourceColumn.tasks.splice(source.index, 1);
        destColumn.tasks.splice(destination.index, 0, movedTask);

        return newColumns;
      });
    },
    [columns, setColumns]
  );

  return (
    <DragDropContext
      onDragEnd={onDragEnd}
      onDragStart={onDragStart}
      onDragUpdate={onDragUpdate}
    >
      <div className="m-auto flex min-h-screen w-full items-center px-[18px] py-[18px] ">
        <div className="flex gap-2 self-start overflow-x-auto relative">
          <Droppable
            droppableId="all-columns"
            direction="horizontal"
            type="column"
          >
            {(provided, snapshot) => (
              <div
                {...provided.droppableProps}
                ref={provided.innerRef}
                className="flex flex-row gap-[12px] "
              >
                {columns.map((column, index) => (
                  <Draggable
                    key={column.id}
                    draggableId={column.id}
                    index={index}
                  >
                    {(provided) => (
                      <div
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                        ref={provided.innerRef}
                      >
                        <Column
                          key={column.id}
                          column={column}
                          deleteColumn={deleteColumn}
                          updateColumn={updateColumn}
                          createTask={createTask}
                          deleteTask={deleteTask}
                          updateTask={updateTask}
                          taskPlaceholderProps={taskPlaceholderProps}
                        ></Column>
                      </div>
                    )}
                  </Draggable>
                ))}

                {provided.placeholder}
                {!isEmpty(columnPlaceholderProps) &&
                  snapshot.isDraggingOver && (
                    <div
                      className="absolute border-2 border-dashed border-gray-400 rounded-lg bg-gray-100 opacity-50 transition-all duration-200 pointer-events-none"
                      style={{
                        top: columnPlaceholderProps.clientY,
                        left: columnPlaceholderProps.clientX,
                        height: columnPlaceholderProps.clientHeight,
                        width: columnPlaceholderProps.clientWidth,
                        pointerEvents: "none",
                      }}
                    />
                  )}
              </div>
            )}
          </Droppable>

          <button
            className="
          h-[42px]
          w-[150px]
          min-w-[150px] 
          px-2
          flex
          items-center  
          justify-between
          cursor-pointer
          text-[12px]
          leading-[24px]
          font-semibold
          text-secondaryGray400
          hover: rounded-md
          hover:bg-secondaryGray800
          ease-in-out 
          duration-300
          ml-[6px]
        "
            onClick={createNewColumn}
          >
            <img src={"/icons/plus.svg"} alt="Plus icon" />
            Добавить колонку
          </button>
        </div>
      </div>
    </DragDropContext>
  );

  function createNewColumn() {
    const newColumn: TColumn = {
      id: Date.now().toString(),
      title: `Sprint ${columns.length + 1}`,
      tasks: [],
    };

    setColumns([...columns, newColumn]);
  }

  function deleteColumn(id: Id) {
    setColumns(columns.filter((column) => column.id !== id));
  }

  function updateColumn(id: Id, title: string) {
    setColumns(
      columns.map((column) =>
        column.id === id ? { ...column, title } : column
      )
    );
  }

  function createTask(columnId: Id) {
    const newTask: TTask = {
      id: Date.now().toString(),
      title: "New task",
    };

    setColumns(
      columns.map((column) =>
        column.id === columnId
          ? { ...column, tasks: [...column.tasks, newTask] }
          : column
      )
    );
  }

  function deleteTask(id: Id) {
    setColumns(
      columns.map((column) => ({
        ...column,
        tasks: column.tasks.filter((task) => task.id !== id),
      }))
    );
  }

  function updateTask(id: Id, title: string) {
    setColumns(
      columns.map((column) => ({
        ...column,
        tasks: column.tasks.map((task) =>
          task.id === id ? { ...task, title } : task
        ),
      }))
    );
  }
};

export default Board;

import { useEffect, useRef, useState } from "react";
import { TColumn, Id } from "../types";
import { Draggable, Droppable } from "react-beautiful-dnd";
import Task from "./Task";
import { isEmpty } from "lodash";

interface ColumnProps {
  column: TColumn;
  deleteColumn: (id: Id) => void;
  updateColumn: (id: Id, title: string) => void;
  createTask: (columnId: Id) => void;
  deleteTask: (id: Id) => void;
  updateTask: (id: Id, title: string) => void;
  taskPlaceholderProps: any;
}

const Column = (props: ColumnProps) => {
  const [editing, setEditing] = useState(false);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  const {
    column,
    deleteColumn,
    updateColumn,
    createTask,
    deleteTask,
    updateTask,
    taskPlaceholderProps,
  } = props;

  useEffect(() => {
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  return (
    <section className="bg-secondaryGray020 w-[300px] h-[694px] rounded-[12px] flex flex-col gap-[12px] relative">
      <div className="h-[20px] cursor-grab flex items-center justify-between gap-[14px] mt-[12px] px-[12px]">
        <div
          className="flex max-w-[199px] w-full h-[12px] "
          onClick={() => setEditing(true)}
        >
          {!editing && (
            <img
              className="mr-[8px]"
              src="/icons/avatar.svg"
              alt="Column status icon"
            />
          )}

          <h1 className="overflow-hidden text-ellipsis whitespace-nowrap text-secondaryGray400 text-sm font-bold leading-[12px] h-[14px]">
            {!editing && column.title}
          </h1>
          {editing && (
            <input
              className="max-w-[199px] w-full text-secondaryGray400 text-sm font-bold italic"
              value={column.title}
              autoFocus
              onBlur={() => setEditing(false)}
              onKeyDown={(e) => {
                if (e.key !== "Enter") return;
                setEditing(false);
              }}
              onChange={(e) => updateColumn(column.id, e.target.value)}
            />
          )}
        </div>
        <div className="flex justify-center items-center gap-[4px] h-[20px]">
          <span className="px-[3px] rounded-[4px] bg-primaryBlue text-xs font-semibold">
            {column.tasks.length}
          </span>
          <button
            className="hover:bg-gray-200 rounded-[4px]"
            onClick={() => {
              createTask(column.id);
            }}
          >
            <img src="icons/plus-blue.svg" alt="Plus icon" />
          </button>
          <button
            className="hover:bg-gray-200 rounded-[4px]"
            onClick={toggleDropdown}
          >
            <img src="/icons/dots-blue.svg" alt="More icon" />
          </button>

          {isDropdownOpen && (
            <div
              ref={dropdownRef}
              className="absolute top-[36px] right-[12px] bg-white border border-gray-300 rounded-md shadow-md px-[6px] py-[2px] flex z-[2]"
            >
              <button
                className=" text-secondaryGray400 text-[12px] font-bold"
                onClick={() => {
                  deleteColumn(column.id);
                  setIsDropdownOpen(false);
                }}
              >
                Удалить колонку
              </button>
            </div>
          )}
        </div>
      </div>

      <Droppable droppableId={column.id} type="task">
        {(provided, snapshot) => (
          <div
            {...provided.droppableProps}
            ref={provided.innerRef}
            className="flex flex-col gap-[10px] h-full overflow-y-auto relative"
          >
            {column.tasks.map((task, index) => (
              <Draggable key={task.id} draggableId={task.id} index={index}>
                {(provided) => (
                  <div
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                    ref={provided.innerRef}
                    className="relative"
                  >
                    <Task
                      key={task.id}
                      task={task}
                      deleteTask={deleteTask}
                      updateTask={updateTask}
                    />
                  </div>
                )}
              </Draggable>
            ))}

            {provided.placeholder}
            {!isEmpty(taskPlaceholderProps) && snapshot.isDraggingOver && (
              <div
                className="absolute border-2 border-dashed border-gray-400 rounded-lg bg-gray-100 opacity-50 transition-all duration-200 pointer-events-none"
                style={{
                  top: taskPlaceholderProps.clientY,
                  left: taskPlaceholderProps.clientX,
                  height: taskPlaceholderProps.clientHeight,
                  width: taskPlaceholderProps.clientWidth,
                  pointerEvents: "none",
                }}
              />
            )}
          </div>
        )}
      </Droppable>
    </section>
  );

  function toggleDropdown() {
    setIsDropdownOpen(!isDropdownOpen);
  }

  function handleClickOutside(e: MouseEvent) {
    if (
      dropdownRef.current &&
      !dropdownRef.current.contains(e.target as Node)
    ) {
      setIsDropdownOpen(false);
    }
  }
};

export default Column;